# CRUD boilerplate
## Прежде, чем начать
Для начала установим необходимый софт, если его ещё нет (все названия - ссылки на странички для загрузки):
* [NodeJS](https://nodejs.org/en/) и npm - чтобы исполнять `.js`-файлы в соответствующией среде и удобно управлять нужными пакетами (npm, скорее всего, установится вместе с `NodeJS`);
* [MongoDB](https://www.mongodb.com/download-center?jmp=nav#community) - База Данных;
* [Git](https://git-scm.com/) - система контроля версий, нужна для корректной работы `npm` (а вообще очень полезная штука, если вы ещё не знакомы с ней, то обязательно хоть немного изучите);
* [VS Code](https://code.visualstudio.com/) - где-то же нужно писать код (да, мы будем писать код). Если вы привыкли к чему-то другому, то этот пункт можно пропустить.

Теперь нам нужно развернуть проект локально, на компьютере, и запустить его. Для этого откроем `Консоль/"Командную строку"/"git bash"` и ввёдем следующий набор команд:
* Клонируем репозиторий
  ```bash
  git clone https://github.com/ifedyukin/CRUD-workshop
  ```
* Переходим в директорию проекта
  ```bash
  cd CRUD-workshop
  ```
* Устанавливаем зависимости
  ```bash
  npm install
  ```
* Запускаем Mongod - [инструкция](https://docs.mongodb.com/manual/administration/install-community/).
* Запускаем проект
  ```bash
  npm start
  ```
* Открывем в браузере адрес `http://localhost:3030/`
> `Консоль/"Командную строку"/"git bash"` закрывать **не нужно**.

## Краткая справка
### HTML, CSS, JavaScript
HTML (от англ. HyperText Markup Language — «язык гипертекстовой разметки») — стандартизированный язык разметки документов во Всемирной паутине. Большинство веб-страниц содержат описание разметки на языке HTML (или XHTML). Язык HTML интерпретируется браузерами; полученный в результате интерпретации форматированный текст отображается на экране монитора компьютера или мобильного устройства.
Основная часть приложения уже готова, нам остаётся доработать его до полностью рабочего состояния, что окажется совсем несложным, если вы будете следовать ниже описанным указаниям.    

CSS (от англ. Cascading Style Sheets — каскадные таблицы стилей) — формальный язык описания внешнего вида документа, написанного с использованием языка разметки.    

JavaScript (аббр. JS) — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией языка ECMAScript (стандарт ECMA-262).    

JavaScript обычно используется как встраиваемый язык для программного доступа к объектам приложений. Наиболее широкое применение находит в браузерах как язык сценариев для придания интерактивности веб-страницам. Также может быть использован для создания утилит, серверных и мобильных приложений и других программных средств.    

Основные архитектурные черты: динамическая типизация, слабая типизация, автоматическое управление памятью, прототипное программирование, функции как объекты первого класса.    

На JavaScript оказали влияние многие языки, при разработке была цель сделать язык похожим на Java, но при этом лёгким для использования непрограммистами. Языком JavaScript не владеет какая-либо компания или организация, что отличает его от ряда языков программирования, используемых в веб-разработке.    

Полезные ссылки:
* [MDN - Введение в HTML](https://developer.mozilla.org/ru/docs/Learn/HTML/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2_HTML);
* [HTML book](http://htmlbook.ru/);
* [Как работает CSS](https://developer.mozilla.org/ru/docs/Learn/CSS/Introduction_to_CSS/How_CSS_works);
* [Современный учебник JavaScript](https://learn.javascript.ru/);
* [MDN - Основы JavaScript](https://developer.mozilla.org/ru/docs/Learn/Getting_started_with_the_web/JavaScript_basics).

### Клиент-серверные web-приложения
Веб-приложение — клиент-серверное приложение, в котором клиент взаимодействует с сервером при помощи браузера, а за сервер отвечает — веб-сервер. Логика веб-приложения распределена между сервером и клиентом, хранение данных осуществляется, преимущественно, на сервере, обмен информацией происходит по сети. Одним из преимуществ такого подхода является тот факт, что клиенты не зависят от конкретной операционной системы пользователя, поэтому веб-приложения являются межплатформенными службами.    

Клиентская часть реализует пользовательский интерфейс, формирует запросы к серверу и обрабатывает ответы от него.    

Серверная часть получает запрос от клиента, выполняет вычисления, после этого формирует веб-страницу и отправляет её клиенту по сети с использованием протокола HTTP.    

Само веб-приложение может выступать в качестве клиента других служб, например, базы данных или другого веб-приложения, расположенного на другом сервере. Ярким примером веб-приложения является система управления содержимым статей Википедии: множество её участников могут принимать участие в создании сетевой энциклопедии, используя для этого браузеры своих операционных систем (будь то Microsoft Windows, GNU/Linux или любая другая операционная система) и не загружая дополнительных исполняемых модулей для работы с базой данных статей.    

Полезные ссылки:
* [Клиент и сервер](https://developer.mozilla.org/ru/docs/Learn/Server-side/First_steps/Client-Server_overview);
* [О модели взаимодействия клиент-сервер простыми словами](https://zametkinapolyah.ru/servera-i-protokoly/o-modeli-vzaimodejstviya-klient-server-prostymi-slovami-arxitektura-klient-server-s-primerami.html).

### CRUD+
CRUD (сокр. от англ. create, read, update, delete — «создать, прочесть, обновить, удалить») — акроним, обозначающий четыре базовые функции, используемые при работе с хранилищами данных:
* создание;
* чтение;
* редактирование;
* удаление.

В нашем случае приложение будет с несколько расширенным функционалом.    
Под CRUD можно подвести практически любое приложение. На основе CRUD можно сделать практически любое приложения.    

### ReactJS, JSX
ReactJS - библиотека (не фреймворк), разрабатываемая "Facebook". Облегчает проектирование и разработку пользовательских интерфейсов и веб-приложений типа "SPA" (Single Page Application). Основными особенностями являются высокий показатель декларативности кода и компонентный подход.

JSX - расширенный синтаксис JavaScript с возможностью использования сущностей, похожих на HTML.

```jsx
class MyComponent extends React.Component {
  render() {
    const Numbers = [1, 2, 3, 4];

    return (
      <div id="numbers-container">
        {Number.map(num => <p>{num}</p>)}
      </div>
    );
  }
}
```

Полезные ссылки:
* [Основы ReactJS](https://learn.javascript.ru/screencast/react);
* [Все фундаментальные принципы ReactJS](https://medium.com/@divermak/%D0%B2%D1%81%D0%B5-%D1%84%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-react-js-%D1%81%D0%BE%D0%B1%D1%80%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B2-%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9-%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B5-ec6a97bfd1bf);
* [Официальный сайт](https://reactjs.org/).

### NodeJS, ExpressJS
Node или Node.js — программная платформа, основанная на движке V8 (транслирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API (написанный на C++), подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода. Node.js применяется преимущественно на сервере, выполняя роль веб-сервера, но есть возможность разрабатывать на Node.js и десктопные оконные приложения (при помощи NW.js, AppJS или Electron для Linux, Windows и macOS) и даже программировать микроконтроллеры (например, tessel и espruino). В основе Node.js лежит событийно-ориентированное и асинхронное (или реактивное) программирование с неблокирующим вводом/выводом.    

Express - это минималистичный и гибкий веб-фреймворк для приложений Node.js, предоставляющий обширный набор функций для мобильных и веб-приложений.    

Полезные ссылки:
* [Начало работы с NodeJS](https://medium.com/devschacht/node-hero-chapter-1-239f7afeb1d1);
* [Node.JS для решения задач](https://learn.javascript.ru/ajax-nodejs);
* [Веб-фреймворк Express](https://developer.mozilla.org/ru/docs/Learn/Server-side/Express_Nodejs);
* [Express - документация](http://expressjs.com/ru/).

### MongoDB, Mongoose
MongoDB (от англ. humongous — огромный) — документоориентированная система управления базами данных (СУБД) с открытым исходным кодом, не требующая описания схемы таблиц. Классифицирована как NoSQL, использует JSON-подобные документы и схему базы данных. Написана на языке C++.

Mongoose - ORM для MongoDB, написана на NodeJS. Позволяет описывать сущности базы данных в виде моделе, а также описывать для них методы для них и взаимодействовать с записями в базе путём вызова методо этих моделей.

```javascript
const UserSchema = new Schema({
  login: { type: String, unique: true, lowercase: true, index: true, required: true },
  password: { type: String, required: true }
});

const allUsers = await UserSchema.find({});
```

В этом листинге мы создаем и записываем в константу `UserSchema` схему с полями `login` и `password`. Через двоеточие для каждой схемы располагается объект (структура типа `ключ: значение`), описывающий параметры для этого поля.     
Для поля `login` мы задали следующие параметры:
* `type: String` - тип этого поля - "строка";
* `unique: true` - значение поля должно быть уникальным;
* `lowercase: true` - значения этого поля будут храниться в нижнем регистре;
* `index: true` - значения этого поля будут использоваться как индексы объекта;
* `required: true` - поле должно быть обязательно заполнено.

После чего выполняем поиск по "таблице" UserSchema с пустыми параметрами запроса `{}`, который вернёт все существующие записи, относящиеся к модели `UserSchema`.

Полезные ссылки:
* [Введение в MongoDB](https://metanit.com/nosql/mongodb/1.1.php);
* [Введение в Mongoose](https://code.tutsplus.com/ru/articles/an-introduction-to-mongoose-for-mongodb-and-nodejs--cms-29527).

## Особенности текущей реализации
### ВКонтакте API
Социальная сеть ВКонтакте предоставляет публичный API для работы с сайтом.     
Запросы к API выглядят следующим образом: `https://api.vk.com/method/метод?параметры'&access_token=токен_доступа&v=версия`.     
Для получения записей пользователя мы воспользуемся методом `wall.get` и передадим в него следующие параметры:
* `filter=owner` - получить записи только этого пользователя;
* `owner_id=ID_пользователя` - id пользователя, со стены которого нужно получить записи.     

Полностью сформированный адрес запроса для получения записей будет выглядеть следующим образом: `'https://api.vk.com/method/wall.get?filter=owner&owner_id=' + vk_user + '&access_token=' + vk_token + '&v=5.69'`.     
Для отправки запроса воспользуемся методом `fetch`, в который передадим нужный адрес, после получения ответа мы должны "разобрать" полученный JSON и записать его в переменную.    
```javascript
const wall = await fetch('https://api.vk.com/method/wall.get?filter=owner&owner_id=' + vk_user + '&access_token=' + vk_token + '&v=5.69')
    .then(response => response.json());
```
Теперь нужно обработать полученные записи, вся информация о них будет храниться в поле `wall.response.items`.    
Для начала отфильтруем записи, воспользуемся методом `filter`: `wall.response.items.filter(post => post.post_type === 'post')`.    
Вызов этого метода вернёт нам только те объекты, что имеют тип `post_type` = `post`. Затем преобразуем каждый из полученных объектов к формату нашей системы с помощью метода `map`, который возвращает массив результатов выполнения функции, переданной в него.
```javascript
const posts = wall.response.items
    .filter(/wall.response.items.filter(post => post.post_type === 'post'))
    .map(post => ({
      _id: post.id,
      url: `https://vk.com/wall${vk_user}_${post.id}`,
      title: post.copy_history ? '[VK-repost]' : '[VK-post]',
      createdAt: post.date * 1000,
      body: getVkPostBody(post),
      type: 'vk',
    }));
```

### Создание пользователя
Для создания пользователя нам нужно отправить post-запрос на `/api/signup` со следующими параметрами:
* login;
* password;
* key - ключ из `src/server/config/index.js` - `createKey`.

```javascript
fetch('http://localhost:3030/api/signup', {
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
  },
  method: 'POST',
  body: `login=root&password=toor&key=webpurple_secret`,
})
```

### Деструктуризация и promise
В коде приложения в некоторых местах используется следующий синтаксис.
```javascript
const { a, b } = obj;
```
Он равносилен следующей записи.
```javascript
const a = obj.a;
const b = obj.b;
```

Также в приложении используются асинхронные функции и promise.    
Promise - "обещание", способ работы с асинхронными функциями, которые требуют ожидания.
```javascript
fetch('url') // делаем запрос на адрес "url"
  .then(response => console.log(response)) // после того, как придёт ответ, выведем его в консоль
  .catch(error => console.error(error)); // если произошла ошибка, выведем её в консоль
```

Помимо обычного представления, promise может быть использован в асинхронной функции.
```javascript
export const method = async (req, res, next) => { // с помощью слова async указываем, что это асинхронная функция
  try {
    const response = await fetch('url'); // делаем запрос, дожидаемся выполнения (await) и записываем результат в переменную
    console.log(response);
  } catch (error) {
    console.log(error); // обрабатываем вероятные ошибки
  }
}
```

### Структура серверной части
Исходный код серверной части размещен в директории `src/server`.    
В этой директории находятся 2 файла и множество директорий. Файл `index.js` отвечает за запуск сервера и инициализацию middleware. В файле `helpers.js` и директории `services` расположены некоторые вспомогательные утилитарные методы.    

#### config
В директории `config` есть только один файл `index.js`, с помощью которого производится конфигурация серверной части проекта.
```javascript
database: '...', // путь к базе данных
port: 3030, // порт, на котором будет запущен сервер
secret: '...', // секретный ключ, необходимый для хеширования паролей
createKey: '...', // // секретный ключ, необходимый для регулирования возможности регистрации пользователя
vk_token: '...', // сервисный токен приложения ВКонтакте
vk_user: '...' // идентификатор пользователя, со стены которого необходимо получать записи
```
#### models
Директория `models` содержит описания моделей базы данных для ORM. Один файл соответствует одной модели, более подробно с описанием моделей можно ознакомиться в разделе "MongoDB, Mongoose".

#### routes
Директория `routes` содержит файлы, задающие соответствие между адресом, на который придёт запрос, и функцией, которая его обработает. Роуты описываются следующим образом.
```javascript
router.post('/posts', checkToken, getUser, PostController.create);
```
Здесь для объекта роутера приложения вызывается метод, соответствующий обрабатываемуму типу запроса, первым параметром передаётся адрес, на который посылается запрос, следующими параметрами передаются функции, выполняющией друг за другом.    
Другими словами, код из сниппета выше "говорит" следующее: "При `post`-запросе на адрес `/post` необходимо выполнить следующую цепочку функций: `checkToken`, `getUser`, `PostController.create`".

#### controllers
Директория `controllers` содержит файлы, в которых определены функции-обработчики (контроллеры) для роутов. Именно эти функции передаются в виде параметров метода роутера.
```javascript
export async function create(req, res, next) {
  const postData = req.body; // получаем информацию из тела запроса
  const userId = req.user._id; // получаем информацию о пользователе

  postData.userId = userId; // и дописываем её в объект информации о записи

  let post;
  try {
    post = await Post.create(postData); // создаём в базе документ
  } catch ({ message }) { // на всякий случай обрабатываем вероятные ошибки
    return next({ // в случае ошибки передаём информацию о ней следующей функции
      status: 400,
      message
    });
  }

  res.post = post; // если всё прошло хорошо, записываем информацию о записи в объект ответа
  next(); // переходим к следующей  функции
}
```
Функция-контроллер представляет собой `async` функцию, которая принимает следующие параметры:
* `req` - объект запроса;
* `res` - объект ответа;
* `next` - следующая функция в цепочке вызовов.

Контроллер выполняет какие-то действия и возвращает результат на клиент. Обычно контроллер обращается к моделям (базе) и выполняет какие-то действия именно с ними.

#### middlewares
В директории `middlewares` располагаются файлы, содержащие функции промежуточной обработки.
Функции промежуточной обработки (middleware) - это функции, имеющие доступ к объекту запроса (req), объекту ответа (res) и к следующей функции промежуточной обработки в цикле “запрос-ответ” приложения. Следующая функция промежуточной обработки, как правило, обозначается переменной next.

Функции промежуточной обработки могут выполнять следующие задачи:
* Выполнение любого кода.
* Внесение изменений в объекты запросов и ответов.
* Завершение цикла “запрос-ответ”.
* Вызов следующей функции промежуточной обработки из стека.

Если текущая функция промежуточной обработки не завершает цикл “запрос-ответ”, она должна вызвать next() для передачи управления следующей функции промежуточной обработки. В противном случае запрос зависнет. Более подробно об этом механизме рассказано в [документации](http://expressjs.com/ru/guide/using-middleware.html).

Как уже понятно, даже функции-контроллеры является `middleware`, а порядок их выполнения задаётся в конфигурации роутера.

### Структура клиентской части
Исходный код клиентской части размещен в директории `src/client`.    
В этой директории находятся 2 файла и несколько директорий. Файл `index.js` отвечает за запуск инициализацию приложения и начальный рендер приложения на страницу. В файле `helpers.js` расположены некоторые вспомогательные утилитарные методы.    

#### styles
В директории `styles` расположены файлы стилей для клиенсткой части приложения. Все стили описаны с помощью CSS.
```css
.post-edit input[type="submit"] {
  float: right;
  margin-top: 7px;
  background: white;
  border-radius: 0;
  color: black;
  cursor: pointer;
}
```
В листинге выше представлен некоторый набор стилей для какого-то элемента.    
Всё, что расположенно до фигурной скобки (`.post-edit input[type="submit"]`) называется селектором. Селектор позволяет выбрать определенные элементы и именно для них определить стили. В фигурных скобках задаются правила, разделяемые `;`. Правило задаётся в формате `название стиля: значение`.

#### components
В директории `components` расположены файлы, описывающие компоненты приложения (и само приложение в целом, так как в среде React всё приложение является просто большим компонентом).    

React-компоненты могут быть определены в виде функций или классов.    
Функциональные компоненты просто отображают какую-то информацию и содержат минимальную логику (или вообще её не содержат).
Классовые компоненты могут не только отображать информацию, но и могут иметь большое число методов (в том числе зависящих от жизненного цикла компонента), а так же могут хранить какое-то состояние.    
Для отображения компонента его необходимо вызвать, в синтаксисе `jsx` это выглядит следующим образом.
```jsx
<div id="post">
  <Post id="post" title="Lorem ipsum" count={1 + 1} />
</div>
```
В листинге мы отобразим обычный блок, внутри которого будет расположен компонент `Post`. В компонент в виде атрибутов передаются параметры, которые называются "props". Атрибуты могут быть как текстом, так и JS-выражениями, выражения должны быть заключены в фигурные скобки.    

В листингах ниже представлены виды описания компонентов.
```jsx
export const Post = (props) => ( // в функциональный компонент объект параметров компонента передается в виде параметра функции
  <div className="post">
    {props.full
      ? <h2 className="post-title">{props.title}</h2>
      : <Link to={`${props.url}`}><h2 className="post-title">{props.title}</h2></Link>
    }
    <span className="post-date">{convertDate(props.createdAt)}</span> {/* внутри html так же могут быть отображены JS-выражения */}
    <div className="post-text" dangerouslySetInnerHTML={{
      __html: props.body,
    }} />
  </div>
);
```

```jsx
export class Count extends React.Component { // комонент-класс должен быть унаследован от React.Component
  constructor(props) { // в параметры конструктора передаются props компонента, так же они будут доступны в поле this.props
    super(props);
    this.state = { // в конструкторе можно задать начальное значение состояния
      count: props.initCount
    }
  }

  increment = () => { // определяем метод инкремента счетчика
    this.setState(prev => { count: prev.count + 1 }); // при вызове этого метода изменяем состояние, используя метод this.setState, в который передаём новое состояние или функцию, которая его изменит
  }

  render() { // компонент-класс должен иметь метод render, которые отобразит компонент
    return ( // этот метод должен вернуть разметку компонента
      <div>
        <span>{this.state.count}</span>
        <button onClick={this.increment}>count++</button> {/* для html-элементов в качестве атрибутов так же могут быть переданы варажения */}
      </div>
    )
  }
};
```

#### Запросы на сервер
Ддя выполнения запросов на сервер используется метод `fetch`.
```javascript
fetch('http://localhost:3030/api/vk') // отправляем запрос на определенный адрес
    .then(response => response.json()) // после ответа преобразуем ответ в формат json
    .then(response => this.setState({ vk: response })); // после преобразования записываем результат в состояние компонента
```

## Обратная связь
* E-mail для связи, вопросов и т.п. - [Igor_Fedyukin@epam.com](mailto:Igor_Fedyukin@epam.com);
* [Feedback form](https://goo.gl/forms/fQ6JB8xjEiD2D5642).
